# 组成原理课程第<span style="display: inline-block; min-width: 30px; border-bottom: 1px solid black;">三</span>次实验报告

# 实验名称：<span style="display: inline-block; min-width: 200px; border-bottom: 1px solid black;">CPU设计基础</span>

<center>
学号：<span style="display: inline-block; min-width: 100px; border-bottom: 1px solid black;">2210556</span>
&emsp;&emsp;&emsp;
姓名：<span style="display: inline-block; min-width: 100px; border-bottom: 1px solid black;">廖望</span>
&emsp;&emsp;&emsp;
班次：<span style="display: inline-block; min-width: 100px; border-bottom: 1px solid black;">张金</span>
</center>

## 一、实验目的

1. 理解寄存器堆在CPU设计中的重要作用及实现方式
2. 掌握同步RAM和异步RAM的工作原理及其区别
3. 培养Verilog硬件设计与调试能力
4. 学习使用Vivado进行硬件设计与调试的方法
5. 为后续CPU设计奠定基础

## 二、实验内容说明

本次实验包含三个主要任务：
1. 寄存器堆仿真实验：完成寄存器堆的仿真，并思考"两读一写"设计的原因
2. 存储器实验：分别实现同步RAM和异步RAM，并分析其特点与区别
3. 调试实验：针对一段存在bug的代码，完成查找、修复和验证过程

## 三、实验原理与分析

### 1. 寄存器堆原理

寄存器堆是CPU中的核心组件，用于临时存储处理器正在使用的数据。其"两读一写"的设计允许CPU在一个时钟周期内同时读取两个操作数并写入一个结果，这对于指令执行效率至关重要。

### 2. 存储器原理

存储器在计算机系统中扮演着数据存储的角色，本实验主要研究两种RAM：

- 同步RAM：在时钟信号的控制下进行读写操作
- 异步RAM：由控制信号直接触发，不依赖时钟

### 3. 调试技术原理

硬件设计的调试是一个系统性工作，需要理解波形图分析、代码审查等多种技术。本实验通过分析波形中的不定值(X)和高阻值(Z)，定位代码问题。

## 四、实验步骤与方法

### 1. 寄存器堆实验

#### 实验过程

1. 将提供的寄存器堆代码导入Vivado项目
2. 编译代码并运行仿真
3. 观察波形图，分析寄存器堆的读写时序

执行仿真后，得到的波形图如下：

![](./pic/1.png)

从波形图中可以观察到：
- rdata1输出的是raddr1地址存储的数据
- rdata2输出的是raddr2地址存储的数据
- 当we=1时，wdata被写入waddr地址
- 对同一地址的读写操作存在冲突，写操作优先，此时读取结果显示为X

#### 数据分析

通过波形图可以清晰地观察到寄存器堆的两读一写特性。当我们尝试同时对一个地址进行读写操作时，波形中显示X表示不定值，这表明寄存器堆的读写冲突处理机制优先执行写操作。

### 2. 同步RAM和异步RAM实验

#### 同步RAM实验步骤

1. 从Vivado的IP catalog中导入同步内存，命名为block_ram
2. 编写测试代码并进行仿真
3. 分析波形图中的时序特性

同步RAM的仿真波形图：

![](./pic/2.png)

观察发现：
- 同步RAM只在时钟上升沿读取数据
- 需要wen和clock均为1才执行写入操作
- 数据读取存在一个时钟周期的延迟

#### 异步RAM实验步骤

1. 从IP catalog导入异步内存，命名为distributed_ram
2. 使用相同的测试代码进行仿真
3. 对比同步RAM与异步RAM的差异

异步RAM的仿真波形图：

![](./pic/3.png)

观察发现：
- 异步RAM在接收地址输入后立即输出该地址的值
- 写操作在wen为1时立即执行
- 写操作期间无法同时读取数据

#### 对比分析

| 特性 | 同步RAM | 异步RAM |
|------|---------|---------|
| 控制方式 | 时钟信号 | 控制信号 |
| 读取时序 | 时钟边沿 | 即时响应 |
| 写入时序 | 时钟边沿且wen=1 | wen=1时立即执行 |
| 适用场景 | 高速系统 | 简单系统或低速场景 |
| 时序控制 | 简单可靠 | 相对复杂 |

### 3. 调试实验

#### 初步分析

1. 导入存在bug的代码到Vivado
2. 编译并进行初始仿真
3. 观察仿真波形中的异常

初始波形图：

![](./pic/4.png)

发现的问题：
- num_a_g输出为不定值X
- num_csn输出为高阻值Z

#### 排查过程

首先分析高阻值Z的原因：

1. 检查代码中num_csn的赋值位置
2. 在show_num模块中发现`assign num_csn = 8'b01111111`
3. 检查show_sw中调用show_num的代码，发现将num_csn错写为num_scn

修复此错误后，得到的波形图：

![](./pic/5.png)

继续分析不定值X的问题：

1. num_a_g的值来自nxt_a_g，而nxt_a_g的值依赖show_data
2. 发现`show <= ~switch`被注释，导致show_data不正确
3. nxt_a_g的case语句中缺少show_data=6的情况
4. 存在组合环路：keep_a_g = nxt_a_g+num_a_g，而nxt_a_g又依赖keep_a_g
5. show_data_r = show_data使用了非阻塞赋值，导致采样问题

#### 修复方案

1. 恢复`show <= ~switch`语句
2. 为nxt_a_g添加show_data=6的处理
3. 修改keep_a_g的赋值为`keep_a_g = num_a_g`
4. 将show_data_r的赋值改为`show_data_r = switch`

修复后的波形图：

![](./pic/6.png)

#### 最终代码

完成修复后，代码如下（关键部分）：

```verilog
module show_sw (
    input             clk,          
    input             resetn,     
    input      [3 :0] switch,    //input
    output     [7 :0] num_csn,   //new value   
    output     [6 :0] num_a_g,      
    output     [3 :0] led        //previous value
);

reg [3:0] show_data; 
reg [3:0] show_data_r; 
reg [3:0] prev_data;

always @(posedge clk) begin
    show_data <= ~switch;     
    show_data_r <= switch; 
end 

//show led: previous value 
assign led = ~prev_data;

//show number: new value 
show_num u_show_num(
    .clk        (clk      ),
    .resetn     (resetn   ),
    .show_data  (show_data),         
    .num_csn    (num_csn  ),
    .num_a_g    (num_a_g  )
);
endmodule
```

## 五、实验结果与分析

### 1. 寄存器堆实验结果

寄存器堆的"两读一写"设计有以下几点优势：

1. **指令执行效率**：CPU指令集中常见的操作是从两个寄存器读取数据，进行运算后写回第三个寄存器。"两读一写"的设计使这类操作能在一个时钟周期内完成。

2. **数据流水线支持**：在多级流水线CPU中，寄存器堆需要同时处理多条指令的读写请求，两读一写架构能满足基本需求。

3. **资源利用率**：在大多数指令执行中，读操作比写操作更频繁，两读一写的比例接近实际需求，提高了资源利用效率。

4. **时序优化**：在执行其他指令时，两读一写的形式允许读写操作同时进行，无需等待下一个时钟周期即可完成操作链。

### 2. 存储器实验结果

同步RAM和异步RAM的比较分析：

**同步RAM优势**：
- 时序控制简单明确，由时钟统一控制
- 适合组成高速系统，时钟同步能力强
- 在高频环境下工作稳定
- 与流水线架构配合良好

**异步RAM优势**：
- 响应速度更快，无需等待时钟边沿
- 设计相对简单，控制信号直接生效
- 低功耗场景下更有优势
- 在简单系统中实现更为直观

同步RAM和异步RAM的本质区别在于时序控制方式，这直接影响了它们的性能特性、复杂度和适用场景。在现代高性能CPU设计中，同步RAM更为常用，而在特定的低功耗或简单控制场景中，异步RAM仍有其应用价值。

### 3. 调试实验结果

通过本次调试实验，总结出以下Vivado调试经验和方法：

1. **波形分析技巧**：
   - 利用波形图中的不定值(X)和高阻值(Z)快速定位问题区域
   - 关注信号变化的时序关系，识别潜在的时序问题
   - 对比预期行为与实际行为的差异

2. **代码审查方法**：
   - 检查变量赋值和使用的完整性
   - 关注信号名称拼写错误（如num_csn误写为num_scn）
   - 查找被注释掉的关键代码（如本例中的`show <= ~switch`）
   - 检查case语句是否完整（如缺少show_data=6的情况）

3. **组合逻辑分析**：
   - 识别组合环路（如keep_a_g和nxt_a_g的相互依赖）
   - 分析阻塞与非阻塞赋值的使用是否合理

4. **系统性调试流程**：
   - 先从顶层症状入手，确定问题表现
   - 逐步缩小问题范围，定位到具体模块和信号
   - 修复一个问题后重新仿真，避免多个修改同时引入
   - 验证修复后的系统行为是否符合预期

## 六、实验总结与体会

通过本次实验，我深入理解了CPU设计中几个关键组件的工作原理和实现方法：

1. 寄存器堆的两读一写设计是指令执行效率的重要保障，它能满足大多数CPU指令的基本需求，使运算操作在一个时钟周期内完成。

2. 同步RAM和异步RAM各有优势，选择哪种类型需要根据具体的应用场景和性能要求。同步RAM适合高速系统，而异步RAM在某些简单场景中更为实用。

3. 硬件调试是一个复杂而系统的过程，需要综合运用波形分析、代码审查等多种技术。通过本次实验，我积累了宝贵的调试经验，提高了发现和修复硬件设计问题的能力。

4. Vivado工具在硬件设计和验证中发挥着重要作用，掌握其使用方法对硬件设计工作至关重要。

这次实验不仅巩固了我对计算机组成原理的理解，也培养了硬件设计和调试的实践能力，为后续更复杂的CPU设计打下了坚实基础。在实验过程中，我深刻体会到细节的重要性，一个小小的拼写错误或逻辑缺陷都可能导致整个系统无法正常工作，这也提醒我在今后的硬件设计中需要更加严谨。 