# MIPS指令执行序列分析 (test.coe)

本文档分析了 `test.coe` 文件中定义的MIPS指令序列。
每条指令都将显示其在 `test.coe` 中的原始二进制形式、对应的MIPS指令码、汇编助记符以及简要的功能描述。
指令地址从0开始，每条指令占用4个字节。

---

| 地址 (Hex) | 二进制指令                     | 指令码 (Op/Funct)          | 汇编指令 (及解析)            | 功能描述                                   |
| :--------- | :------------------------------- | :------------------------- | :--------------------------- | :----------------------------------------- |
| 0x00000000 | `00100100000000010000000000000001` | `001001`                   | `ADDIU $1, $0, 1`            | $1 = $0 + 1 (1)                            |
| 0x00000004 | `00000000000000010001000100000000` | `000000 / 100000` (ADDU)   | `ADDU $1, $0, $1`            | $1 = $0 + $1                               |
| 0x00000008 | `00000000010000010001100000100001` | `000000 / 100001` (ADDU)   | `ADDU $3, $2, $1`            | $3 = $2 + $1                               |
| 0x0000000C | `00000000000000100010000010000010` | `000000 / 000010` (SRL)    | `SRL $4, $2, 0`              | $4 = $2 >> 0 (逻辑右移0位)                  |
| 0x00000010 | `00101000100110010000000000000101` | `001010`                   | `SLTI $25, $4, 5`            | $25 = ($4 < 5) ? 1 : 0 (有符号)              |
| 0x00000014 | `00000111001000010000000000010000` | `000001` (BGEZ, rt=00001)  | `BGEZ $9, 16 (offset << 2)`  | if ($9 >= 0) PC = PC + 4 + (16 << 2)       |
| 0x00000018 | `00000000011001000010100000100011` | `000000 / 100011` (SUBU)   | `SUBU $5, $3, $4`            | $5 = $3 - $4                               |
| 0x0000001C | `10101100000001010000000000010100` | `101011`                   | `SW $5, 20($0)`              | M[$0 + 20] = $5                            |
| 0x00000020 | `00000000101000100011000000100111` | `000000 / 100111` (NOR)    | `NOR $6, $5, $2`             | $6 = ~($5 | $2)                           |
| 0x00000024 | `00000000110000110011100000100101` | `000000 / 100101` (OR)     | `OR $7, $6, $3`              | $7 = $6 | $3                               |
| 0x00000028 | `00000000111001100100000000100110` | `000000 / 100110` (XOR)    | `XOR $8, $7, $6`             | $8 = $7 ^ $6                               |
| 0x0000002C | `10101100000010000000000000011100` | `101011`                   | `SW $8, 28($0)`              | M[$0 + 28] = $8                            |
| 0x00000030 | `00010001000000110000000000000010` | `000100`                   | `BEQ $8, $3, 2 (offset << 2)` | if ($8 == $3) PC = PC + 4 + (2 << 2)       |
| 0x00000034 | `00000000110001110100100000101010` | `000000 / 101010` (SLT)    | `SLT $9, $6, $7`             | $9 = ($6 < $7) ? 1 : 0 (有符号)              |
| 0x00000038 | `00100100000000010000000000001000` | `001001`                   | `ADDIU $1, $0, 8`            | $1 = $0 + 8                                |
| 0x0000003C | `10001100001010100000000000010100` | `100011`                   | `LW $10, 20($1)`             | $10 = M[$1 + 20]                           |
| 0x00000040 | `00010101010001010000000000000100` | `000101`                   | `BNE $10, $5, 4 (offset << 2)`| if ($10 != $5) PC = PC + 4 + (4 << 2)      |
| 0x00000044 | `00000000010000010101100000100100` | `000000 / 100100` (AND)    | `AND $11, $2, $1`            | $11 = $2 & $1                              |
| 0x00000048 | `10101100001010110000000000011100` | `101011`                   | `SW $11, 28($1)`             | M[$1 + 28] = $11                           |
| 0x0000004C | `10101100001001000000000000010000` | `101011`                   | `SW $4, 16($1)`              | M[$1 + 16] = $4                            |
| 0x00000050 | `00001100000000000000000000011001` | `000011`                   | `JAL 0x00000019 (target << 2)` | $31 = PC + 8; PC = (PC_upper_4_bits_concat_target_26_bits) << 2. Target address: 0x00000064 |
| 0x00000054 | `00111100000011000000000000001100` | `001111`                   | `LUI $12, 12`                | $12 = 12 << 16                             |
| 0x00000058 | `00000000010011001101000000000111` | `000000 / 000111` (SRAV)   | `SRAV $13, $12, $2`          | $13 = $12 >> $2 (算术右移, $2指定位数)      |
| 0x0000005C | `00000000001110101101100000000100` | `000000 / 000100` (SLLV)   | `SLLV $14, $10, $3`          | $14 = $10 << $3 (逻辑左移, $3指定位数)      |
| 0x00000060 | `00000011011000001111100000001001` | `000000 / 001001` (JALR)   | `JALR $31, $27`              | $31 = PC + 8; PC = $27                     |
| 0x00000064 | `10100000011110100000000000000101` | `101000`                   | `SB $26, 5($3)`              | M[$3 + 5] = $26[7:0]                       |
| 0x00000068 | `00000000011000110110100000101011` | `000000 / 101011` (SLTU)   | `SLTU $13, $3, $3`           | $13 = ($3 < $3) ? 1 : 0 (无符号)            |
| 0x0000006C | `00011101101000000000000000000011` | `000111` (BGTZ, rt=00000)  | `BGTZ $13, 3 (offset << 2)`  | if ($13 > 0) PC = PC + 4 + (3 << 2)        |
| 0x00000070 | `00000000100001100111000000000100` | `000000 / 000000` (SLL)    | `SLL $14, $6, 16`            | $14 = $6 << 16 (逻辑左移16位)               |
| 0x00000074 | `00000000000011100111100010000011` | `000000 / 000011` (SRA)    | `SRA $15, $14, 0`            | $15 = $14 >> 0 (算术右移0位)               |
| 0x00000078 | `00000000001011111000000000000110` | `000000 / 000110` (SRLV)   | `SRLV $16, $15, $2`          | $16 = $15 >> $2 (逻辑右移, $2指定位数)      |
| 0x0000007C | `00011010000000000000000000001000` | `000110` (BLEZ, rt=00000)  | `BLEZ $0, 8 (offset << 2)`   | if ($0 <= 0) PC = PC + 4 + (8 << 2)        |
| 0x00000080 | `00000000001011111000000000000111` | `000000 / 000111` (SRAV)   | `SRAV $16, $15, $2`          | $16 = $15 >> $2 (算术右移, $2指定位数)      |
| 0x00000084 | `00100100000010110000000010001100` | `001001`                   | `ADDIU $11, $0, 140`         | $11 = $0 + 140                             |
| 0x00000088 | `00000110000000000000000000000110` | `000001` (BLTZ, rt=00000)  | `BLTZ $0, 6 (offset << 2)`   | if ($0 < 0) PC = PC + 4 + (6 << 2)         |
| 0x0000008C | `10001101010111000000000000000011` | `100011`                   | `LW $28, 3($13)`             | $28 = M[$13 + 3]                           |
| 0x00000090 | `00010111100111010000000000000111` | `000101`                   | `BNE $28, $29, 7 (offset << 2)`| if ($28 != $29) PC = PC + 4 + (7 << 2)     |
| 0x00000094 | `10100000101011110000000000001000` | `101000`                   | `SB $15, 8($5)`              | M[$5 + 8] = $15[7:0]                       |
| 0x00000098 | `10000000101100100000000000001000` | `100000`                   | `LB $18, 8($5)`              | $18 = sign_extend(M[$5 + 8])               |
| 0x0000009C | `10010000101100110000000000001000` | `100100`                   | `LBU $19, 8($5)`             | $19 = zero_extend(M[$5 + 8])               |
| 0x000000A0 | `00101101111110001111111111111111` | `001011`                   | `SLTIU $24, $29, -1`         | $24 = ($29 < -1) ? 1 : 0 (无符号, -1会转为大正数) |
| 0x000000A4 | `00000001100001011110100000100101` | `000000 / 100101` (OR)     | `OR $29, $12, $5`            | $29 = $12 | $5                             |
| 0x000000A8 | `00000001011000000000000000001000` | `000000 / 001000` (JR)     | `JR $11`                     | PC = $11                                   |
| 0x000000AC | `00110001111101001111111111111111` | `001100`                   | `ANDI $20, $15, 65535`       | $20 = $15 & 0xFFFF                         |
| 0x000000B0 | `00110101111101011111111111111111` | `001101`                   | `ORI $21, $15, 65535`        | $21 = $15 | 0xFFFF                         |
| 0x000000B4 | `00111001111101101111111111111111` | `001110`                   | `XORI $22, $15, 65535`       | $22 = $15 ^ 0xFFFF                         |
| 0x000000B8 | `00001000000000000000000000000000` | `000010`                   | `J 0x00000000 (target << 2)` | PC = (PC_upper_4_bits_concat_target_26_bits) << 2. Target address: 0x00000000 |

---

**注意:**
*   对于分支指令 (BEQ, BNE, BGEZ, BGTZ, BLEZ, BLTZ)，`offset` 是相对于 `PC+4` 的指令数偏移。实际跳转地址是 `PC + 4 + (sign_extended(offset) << 2)`。
*   对于J型指令 (J, JAL)，`target` 是一个26位的地址字段，实际跳转地址是 `(PC_upper_4_bits_concat_target_26_bits) << 2`。
*   对于JALR指令，目标地址直接来自寄存器 `rs`。
*   立即数字段 `imm` 根据指令类型（如ADDIU, SLTI vs. ANDI, ORI, LUI）进行符号扩展或零扩展。
*   为了简洁，上述汇编指令中的立即数和偏移量直接显示了其十进制或十六进制值，具体计算和扩展方式如MIPS标准定义。 